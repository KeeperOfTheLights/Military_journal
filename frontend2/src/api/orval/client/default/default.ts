/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Military Journal API
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DebugTokenDebugTokenGetParams,
  ErrorResponse
} from '.././model';

import { customInstance } from '../../custom-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Serve uploaded media files with CORS support.
 * @summary Serve Media
 */
export type serveMediaMediaFilePathGetResponse200 = {
  data: unknown
  status: 200
}

export type serveMediaMediaFilePathGetResponse401 = {
  data: ErrorResponse
  status: 401
}

export type serveMediaMediaFilePathGetResponse403 = {
  data: ErrorResponse
  status: 403
}

export type serveMediaMediaFilePathGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type serveMediaMediaFilePathGetResponse422 = {
  data: ErrorResponse
  status: 422
}

export type serveMediaMediaFilePathGetResponse429 = {
  data: ErrorResponse
  status: 429
}
    
export type serveMediaMediaFilePathGetResponseSuccess = (serveMediaMediaFilePathGetResponse200) & {
  headers: Headers;
};
export type serveMediaMediaFilePathGetResponseError = (serveMediaMediaFilePathGetResponse401 | serveMediaMediaFilePathGetResponse403 | serveMediaMediaFilePathGetResponse404 | serveMediaMediaFilePathGetResponse422 | serveMediaMediaFilePathGetResponse429) & {
  headers: Headers;
};

export type serveMediaMediaFilePathGetResponse = (serveMediaMediaFilePathGetResponseSuccess | serveMediaMediaFilePathGetResponseError)

export const getServeMediaMediaFilePathGetUrl = (filePath: string,) => {


  

  return `/media/${filePath}`
}

export const serveMediaMediaFilePathGet = async (filePath: string, options?: RequestInit): Promise<serveMediaMediaFilePathGetResponse> => {
  
  return customInstance<serveMediaMediaFilePathGetResponse>(getServeMediaMediaFilePathGetUrl(filePath),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getServeMediaMediaFilePathGetQueryKey = (filePath: string,) => {
    return [
    `/media/${filePath}`
    ] as const;
    }

    
export const getServeMediaMediaFilePathGetQueryOptions = <TData = Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError = ErrorResponse>(filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServeMediaMediaFilePathGetQueryKey(filePath);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>> = ({ signal }) => serveMediaMediaFilePathGet(filePath, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(filePath), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ServeMediaMediaFilePathGetQueryResult = NonNullable<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>>
export type ServeMediaMediaFilePathGetQueryError = ErrorResponse


export function useServeMediaMediaFilePathGet<TData = Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError = ErrorResponse>(
 filePath: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>,
          TError,
          Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServeMediaMediaFilePathGet<TData = Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError = ErrorResponse>(
 filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>,
          TError,
          Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServeMediaMediaFilePathGet<TData = Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError = ErrorResponse>(
 filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Serve Media
 */

export function useServeMediaMediaFilePathGet<TData = Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError = ErrorResponse>(
 filePath: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof serveMediaMediaFilePathGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getServeMediaMediaFilePathGetQueryOptions(filePath,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Root endpoint.
 * @summary Root
 */
export type rootGetResponse200 = {
  data: unknown
  status: 200
}

export type rootGetResponse401 = {
  data: ErrorResponse
  status: 401
}

export type rootGetResponse403 = {
  data: ErrorResponse
  status: 403
}

export type rootGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type rootGetResponse422 = {
  data: ErrorResponse
  status: 422
}

export type rootGetResponse429 = {
  data: ErrorResponse
  status: 429
}
    
export type rootGetResponseSuccess = (rootGetResponse200) & {
  headers: Headers;
};
export type rootGetResponseError = (rootGetResponse401 | rootGetResponse403 | rootGetResponse404 | rootGetResponse422 | rootGetResponse429) & {
  headers: Headers;
};

export type rootGetResponse = (rootGetResponseSuccess | rootGetResponseError)

export const getRootGetUrl = () => {


  

  return `/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {
  
  return customInstance<rootGetResponse>(getRootGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getRootGetQueryKey = () => {
    return [
    `/`
    ] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = ErrorResponse


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Health check endpoint.
 * @summary Health Check
 */
export type healthCheckHealthGetResponse200 = {
  data: unknown
  status: 200
}

export type healthCheckHealthGetResponse401 = {
  data: ErrorResponse
  status: 401
}

export type healthCheckHealthGetResponse403 = {
  data: ErrorResponse
  status: 403
}

export type healthCheckHealthGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type healthCheckHealthGetResponse422 = {
  data: ErrorResponse
  status: 422
}

export type healthCheckHealthGetResponse429 = {
  data: ErrorResponse
  status: 429
}
    
export type healthCheckHealthGetResponseSuccess = (healthCheckHealthGetResponse200) & {
  headers: Headers;
};
export type healthCheckHealthGetResponseError = (healthCheckHealthGetResponse401 | healthCheckHealthGetResponse403 | healthCheckHealthGetResponse404 | healthCheckHealthGetResponse422 | healthCheckHealthGetResponse429) & {
  headers: Headers;
};

export type healthCheckHealthGetResponse = (healthCheckHealthGetResponseSuccess | healthCheckHealthGetResponseError)

export const getHealthCheckHealthGetUrl = () => {


  

  return `/health`
}

export const healthCheckHealthGet = async ( options?: RequestInit): Promise<healthCheckHealthGetResponse> => {
  
  return customInstance<healthCheckHealthGetResponse>(getHealthCheckHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getHealthCheckHealthGetQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = ErrorResponse


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Debug endpoint to test token decoding.
 * @summary Debug Token
 */
export type debugTokenDebugTokenGetResponse200 = {
  data: unknown
  status: 200
}

export type debugTokenDebugTokenGetResponse401 = {
  data: ErrorResponse
  status: 401
}

export type debugTokenDebugTokenGetResponse403 = {
  data: ErrorResponse
  status: 403
}

export type debugTokenDebugTokenGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type debugTokenDebugTokenGetResponse422 = {
  data: ErrorResponse
  status: 422
}

export type debugTokenDebugTokenGetResponse429 = {
  data: ErrorResponse
  status: 429
}
    
export type debugTokenDebugTokenGetResponseSuccess = (debugTokenDebugTokenGetResponse200) & {
  headers: Headers;
};
export type debugTokenDebugTokenGetResponseError = (debugTokenDebugTokenGetResponse401 | debugTokenDebugTokenGetResponse403 | debugTokenDebugTokenGetResponse404 | debugTokenDebugTokenGetResponse422 | debugTokenDebugTokenGetResponse429) & {
  headers: Headers;
};

export type debugTokenDebugTokenGetResponse = (debugTokenDebugTokenGetResponseSuccess | debugTokenDebugTokenGetResponseError)

export const getDebugTokenDebugTokenGetUrl = (params?: DebugTokenDebugTokenGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/debug/token?${stringifiedParams}` : `/debug/token`
}

export const debugTokenDebugTokenGet = async (params?: DebugTokenDebugTokenGetParams, options?: RequestInit): Promise<debugTokenDebugTokenGetResponse> => {
  
  return customInstance<debugTokenDebugTokenGetResponse>(getDebugTokenDebugTokenGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDebugTokenDebugTokenGetQueryKey = (params?: DebugTokenDebugTokenGetParams,) => {
    return [
    `/debug/token`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getDebugTokenDebugTokenGetQueryOptions = <TData = Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError = ErrorResponse>(params?: DebugTokenDebugTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDebugTokenDebugTokenGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>> = ({ signal }) => debugTokenDebugTokenGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DebugTokenDebugTokenGetQueryResult = NonNullable<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>>
export type DebugTokenDebugTokenGetQueryError = ErrorResponse


export function useDebugTokenDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError = ErrorResponse>(
 params: undefined |  DebugTokenDebugTokenGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugTokenDebugTokenGet>>,
          TError,
          Awaited<ReturnType<typeof debugTokenDebugTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDebugTokenDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError = ErrorResponse>(
 params?: DebugTokenDebugTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof debugTokenDebugTokenGet>>,
          TError,
          Awaited<ReturnType<typeof debugTokenDebugTokenGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDebugTokenDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError = ErrorResponse>(
 params?: DebugTokenDebugTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Debug Token
 */

export function useDebugTokenDebugTokenGet<TData = Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError = ErrorResponse>(
 params?: DebugTokenDebugTokenGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof debugTokenDebugTokenGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDebugTokenDebugTokenGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get information about the database being used.
 * @summary Database Info
 */
export type databaseInfoDatabaseInfoGetResponse200 = {
  data: unknown
  status: 200
}

export type databaseInfoDatabaseInfoGetResponse401 = {
  data: ErrorResponse
  status: 401
}

export type databaseInfoDatabaseInfoGetResponse403 = {
  data: ErrorResponse
  status: 403
}

export type databaseInfoDatabaseInfoGetResponse404 = {
  data: ErrorResponse
  status: 404
}

export type databaseInfoDatabaseInfoGetResponse422 = {
  data: ErrorResponse
  status: 422
}

export type databaseInfoDatabaseInfoGetResponse429 = {
  data: ErrorResponse
  status: 429
}
    
export type databaseInfoDatabaseInfoGetResponseSuccess = (databaseInfoDatabaseInfoGetResponse200) & {
  headers: Headers;
};
export type databaseInfoDatabaseInfoGetResponseError = (databaseInfoDatabaseInfoGetResponse401 | databaseInfoDatabaseInfoGetResponse403 | databaseInfoDatabaseInfoGetResponse404 | databaseInfoDatabaseInfoGetResponse422 | databaseInfoDatabaseInfoGetResponse429) & {
  headers: Headers;
};

export type databaseInfoDatabaseInfoGetResponse = (databaseInfoDatabaseInfoGetResponseSuccess | databaseInfoDatabaseInfoGetResponseError)

export const getDatabaseInfoDatabaseInfoGetUrl = () => {


  

  return `/database-info`
}

export const databaseInfoDatabaseInfoGet = async ( options?: RequestInit): Promise<databaseInfoDatabaseInfoGetResponse> => {
  
  return customInstance<databaseInfoDatabaseInfoGetResponse>(getDatabaseInfoDatabaseInfoGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getDatabaseInfoDatabaseInfoGetQueryKey = () => {
    return [
    `/database-info`
    ] as const;
    }

    
export const getDatabaseInfoDatabaseInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDatabaseInfoDatabaseInfoGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>> = ({ signal }) => databaseInfoDatabaseInfoGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DatabaseInfoDatabaseInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>>
export type DatabaseInfoDatabaseInfoGetQueryError = ErrorResponse


export function useDatabaseInfoDatabaseInfoGet<TData = Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>,
          TError,
          Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatabaseInfoDatabaseInfoGet<TData = Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>,
          TError,
          Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDatabaseInfoDatabaseInfoGet<TData = Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Database Info
 */

export function useDatabaseInfoDatabaseInfoGet<TData = Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof databaseInfoDatabaseInfoGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDatabaseInfoDatabaseInfoGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




